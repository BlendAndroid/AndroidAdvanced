package com.blend.algorithm.stack;

/**
 * 栈是限定仅在表尾进行插入和删除操作的线性表。
 * 允许插入和删除的一端称为栈顶（top），另一端称为栈底（bottom），不含任何数据元素的栈称为空栈。栈又称为后进先出的线性表。
 * 逆波兰表达式：
 * 标准四则运算表达式—中缀表达式 9+(3-1)X3+10/2
 * 计算机采用—后缀表达式 9 3 1 - 3 * + 10 2 / +
 * 中缀表达式转换为后缀表达式：数字输出，运算符进栈，括号匹配出栈，比栈顶优先级低就出栈（表中1>2）
 * <p>
 * 递归：程序调用自身的编程技巧称为递归（recursion）。 递归做为一种算法在程序设计语言中广泛应用。 一个过程或函数在其定义
 * 或说明中有直接或间接调用自身的一种方法， 它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解， 递
 * 归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。 递归的能力在于用有限的语句来定义
 * 对象的无限集合。
 * 一般来说，递归需要有边界条件、递归前进段和递归返回段。 当边界条件不满足时，递归前进；当边界条件满足时，递归返回。
 * <p>
 * <p>
 * <p>
 * Hash表：哈希表（Hash table，也叫散列表） 是根据关键码值(Key value)而直接进行访问的数据结构，它通过把关键码值映射到表中
 * 一个位置来访问记录，以加快查找的速度。
 * 比较：
 * 数组(顺序表)：寻址容易。
 * 链表：插入与删除容易。
 * 哈希表：寻址容易，插入删除也容易的数据结构。
 * 散列函数与散列表大小hash冲突的解决方案：装填因子。
 * 为什么需要这个值？因为数据越接近数组最大值，可能产生冲突的情况就越多。
 * 缺点：扩容需要消费大量的空间和性能。
 * 应用：电话号码，字典，点歌系统，QQ，微信的好友等。
 * <p>
 * Hash源码中的设计：拉链发
 * 1.jdk1.8以前。数组 + 链表。
 * 2.jdk1.8之后。当链表的长度超过阈值时，链表就转换为红黑树。
 */
public class MyStack {

    /**
     * 汉诺塔问题
     *
     * @param n 盘子的个数
     * @param A 开始的柱子
     * @param B 中间的柱子
     * @param C 结果的柱子
     */
    public static void hanoi(int n, int A, int B, int C) {
        if (n <= 1) {
            System.out.println(A + "----->" + C);
        } else {
            hanoi(n - 1, A, C, B);  //表示先将n-1个由A移到到B
            System.out.println(A + "----->" + C);   //输出移动的过程
            hanoi(n - 1, B, A, C);  //最后再将n-1由B移动到C
        }
    }
}
