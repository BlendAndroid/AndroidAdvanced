package com.blend.algorithm.tree;


/**
 * 红黑树：R-B Tree，全称是Red-Black Tree。红黑树是一种自平衡二叉查找树，红黑树和平衡二叉树(AVL树)都是二叉查找树的变体，但红黑树的统计性能要好于AVL树。
 * 因为，AVL树是严格维持平衡的，红黑树是黑平衡的。维持平衡需要额外的操作，这就加大了数据结构的时间复杂度，所以红黑树可以看作是
 * 二叉搜索树和AVL树的一个折中，维持平衡的同时也不需要花太多时间维护数据结构的性质。
 * 它是复杂的，但它的操作有着良好的最坏情况运行时间，并且在实践中是高效的: 它可以在O(log n)时间内做查找，插入和删除等操作。
 * <p>
 * 红黑树的特性:
 * 1.每个结点是黑色或者红色。
 * 2.根结点是黑色。
 * 3.每个叶子结点（NIL）是黑色。 [注意：这里叶子结点，是指为空(NIL或NULL)的叶子结点！]
 * 4.如果一个结点是红色的，则它的子结点必须是黑色的。
 * 5.每个结点到叶子结点NIL所经过的黑色结点的个数一样的。[确保没有一条路径会比其他路径长出俩倍，所以红黑树是相对接近平衡的二叉树的！]，
 * 是一种黑结点的平衡树。
 * 6.刚插入的节点为红色，即一个节点初始化时为红色。
 * <p>
 * 红黑树在很多地方都有应用，例如：
 * 1.C++的STL，map和set都是用红黑树实现的。
 * 2.著名的linux进程调度Completely Fair Scheduler，用红黑树管理进程控制块。
 * 3.epoll在内核中的实现，用红黑树管理事件块。
 * 4.nginx用红黑树管理timer等。
 * 5.Java的TreeMap，HashMap，HashTable实现。
 * <p>
 * 插入：
 * 1.插入节点：先按照二叉排序树的方式插入一个节点（红色）
 * 2.插入的是根节点。解决：直接将节点涂黑。
 * 3.插入的节点的父节点是黑色，不违背任何性质，不用调整。
 * 4.插入节点的父节点是红色。
 * 1)父节点是祖父节点的左孩子。
 * 情况1：祖父节点的另一个子节点（叔叔节点）是红色。对策： 将当前节点的父节点和叔叔节点涂黑，祖父节点涂红，把当前节点指向祖父节点，从新的当前节点开始算法。
 * 情况2：叔叔节点是黑色。
 * 情况2.1：当前节点是其父节点的右孩子。对策：当前节点的父节点做为新的当前节点，以新当前节点为支点左旋。
 * 情况2.2：当前节点是其父节点的左孩子。对策：父节点变为黑色，祖父节点变红色，再祖父节点为支点进行右旋。
 * 2)父节点是祖父节点的右孩子。和上面情况一样，将左全部变成右即可。
 */
public class RBTree {

}
